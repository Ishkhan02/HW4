In this assignment, I explored the C compilation process in detail, focusing on how source code is transformed into object files and then linked into an executable. The goal was to understand the role of compilation units, the differences between object files and executables, and how to use tools like nm, objdump, and readelf to inspect them.

I began by writing a small multi-file program. The project consisted of three files: main.c contained the main() function and called a utility function; math_utils.c implemented that utility function, square(), which simply returned the square of an integer; and math_utils.h served as the header with the function declaration. After writing the program, I compiled each source file separately into object files using gcc -c, which gave me main.o and math_utils.o. I then linked them into a final executable, square_prog. Running the program printed the expected result, 49, confirming that everything worked correctly.

With the compiled files in hand, I examined them using nm. The output for main.o showed that it defined the symbol main but had an undefined reference to square. In contrast, math_utils.o defined square. In the final executable, both symbols were resolved, and I could also see other runtime library symbols. This demonstrated clearly how the linkerâ€™s job is to match undefined references with their definitions.

Next, I looked at the disassembly with objdump -d. In the object files, function calls were still placeholders with relocation entries. In the executable, however, the calls were resolved into actual instructions with entries in the Procedure Linkage Table (PLT) and Global Offset Table (GOT). This showed the difference between relocatable object code and fully linked machine code.

Finally, I examined the ELF structure with readelf. The object files were of type REL (Relocatable) and contained relocation sections and full symbol tables. The executable was of type EXEC (or sometimes DYN if compiled as a Position Independent Executable). It contained runtime sections like .interp, .plt, .got, and .dynsym, while the relocation sections were gone since the linker had already processed them.

Through this exercise, I saw how the compilation and linking process gradually transforms human-readable code into an independent, runnable binary. The tools provided concrete evidence of what happens behind the scenes: object files contain unresolved symbols and relocation information, while the final executable is a stitched-together program with assigned addresses and an entry point. The linker is the stage that makes everything whole, resolving dependencies and preparing the program for execution.
